<!DOCTYPE html>  
<html lang="ko">  
<head>  
<meta charset="utf-8">  
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">  
<title>탄막 피하기</title>  
<style>  
html,body{ margin:0; height:100%; background:#1A1A1A; color:#fff; font-family:sans-serif; user-select:none; overflow: hidden; touch-action: none; }  
.wrap{ width: 100vw; height: 100vh; display:flex; flex-direction: column; align-items:center; justify-content:center; }  
.hidden{display:none !important}  
#menu, #modeSelect, #select { text-align:center; width: 100%; }  
h1 { font-size:36px; margin-bottom:15px; font-weight: bold; min-height: 44px; }  

.menu-btn { 
    width:180px; height: 48px; padding: 0; display: flex; align-items: center; justify-content: center; 
    margin: 8px auto; background:#333; border-radius:12px; font-size:18px; cursor: pointer; 
    transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); position: relative; z-index: 2; box-sizing: border-box;
}  
.menu-btn:active{background:#555}  

.exit-container { position: relative; width: 180px; height: 48px; margin: 8px auto; }
.secret-text { 
    position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; 
    justify-content: center; font-size: 24px; font-weight: bold; color: #555; z-index: 1; opacity: 0; 
    transition: opacity 0.5s; pointer-events: none; 
}

.scene-title { font-size:24px; margin-bottom:15px; font-weight: bold; color: #aaa; }  
.mode-card { width: 85%; max-width: 350px; margin: 6px auto; padding: 10px 15px; background: #252525; border-radius: 12px; cursor: pointer; text-align: left; border: 1px solid #333; }
.mode-card:active { background: #333; }
.m-title { font-size: 18px; font-weight: bold; margin-bottom: 3px; }
.m-desc { font-size: 11px; color: #bbb; line-height: 1.3; }
#select { width:90%; max-width:400px; }  
.char-row { display:flex; flex-wrap: wrap; justify-content:center; gap: 8px; }  
.char-btn { width:64px; background:#222; border-radius:10px; padding:8px 4px; text-align:center; cursor: pointer; display: flex; flex-direction: column; align-items: center; }  
.char-btn:active{background:#444}  
.char-preview { width:40px; height:40px; margin-bottom: 4px; }  
.char-name { font-size:10px; font-weight:600; line-height: 1.2; white-space: pre; }  
.back-btn { position: absolute; left: 20px; bottom: 20px; padding: 10px 20px; background: #333; border-radius: 8px; font-size: 14px; cursor: pointer; z-index: 10; }
.back-btn:active { background: #444; }
#game { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%; }
#topUI { width: 90vmin; max-width: 400px; display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 8px; font-weight: bold; }
.score-box { display: flex; flex-direction: column; align-items: flex-start; position: relative; max-width: 70%; }
#badgeContainer { display: flex; gap: 4px; margin-bottom: 6px; min-height: 14px; flex-wrap: wrap; align-items: center; }
.badge { width: 10px; height: 10px; animation: rainbow-all 2s linear infinite; position: relative; flex-shrink: 0; }
.badge.extreme-badge { animation: none; background: #FF0000; border: 1px solid #FF8888; }
.badge.circle-fill { border-radius: 50%; background:!important; }
.badge.circle-fill.extreme { background: #FF0000 !important; } 
.badge.circle-fill.rainbow { animation: rainbow-all 2s linear infinite !important; border: none; }
.badge.star { clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%); width: 14px; height: 14px; }
.badge.octagon { clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%); }
@keyframes rainbow-all { 0% { background: #FF0000; } 20% { background: #FFFF00; } 40% { background: #00FF00; } 60% { background: #00FFFF; } 80% { background: #0000FF; } 100% { background: #FF00FF; } }
#collisionDisplay { font-size: 14px; color: #FFFFFF; margin-bottom: 2px; }
.ui-item { font-size: 14px; }
.btn-small { background: #333; padding: 5px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; }
.frame { width: 90vmin; height: 90vmin; max-width: 400px; max-height: 400px; background: #000; border: 4px solid #333; position: relative; overflow: hidden; box-sizing: border-box; }  
canvas { width: 100%; height: 100%; }  
.controls { width: 90vmin; max-width: 400px; display: flex; gap: 10px; margin-top: 10px; height: 15vh; max-height: 80px; }  
.ctrl { flex: 1; height: 100%; background: #333; border-radius: 16px; display: flex; align-items: center; justify-content: center; touch-action: none; }  
.ctrl.active { background: #555; }
.arrow { width: 18px; height: 18px; border: 4px solid #fff; border-top: none; border-right: none; transform: rotate(45deg); }  
.right .arrow { transform: rotate(-135deg); }  
#overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; }
.overlay-content { text-align: center; }
.overlay-msg { font-size: 18px; margin-bottom: 15px; color: #fff; }
.overlay-btns { display: flex; gap: 15px; }
.overlay-btn { background: #444; color: #fff; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 14px; }
.countdown-text { font-size: 50px; font-weight: bold; }

#menuCanvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
</style>  
</head>  
<body>  
<canvas id="menuCanvas"></canvas>
<div class="wrap">  
<div id="menu">  
  <h1 id="gameTitle">《 탄막 피하기 》</h1>  
  <div class="menu-btn" id="startBtn">시작하기</div>  
  <div class="exit-container">
    <div class="secret-text" id="deltaHint">Δ?</div>
    <div class="menu-btn" id="exitRealBtn">나가기</div>  
  </div>
</div>  

<div id="modeSelect" class="hidden">
  <div class="scene-title">모드 선택</div>
  <div class="mode-card" data-mode="easy"><div class="m-title" style="color:#4CAF50">쉬움</div><div class="m-desc">하남자를 위한 모드입니다.</div></div>
  <div class="mode-card" data-mode="normal"><div class="m-title" style="color:#FFEB3B">중간</div><div class="m-desc">기본 모드입니다.</div></div>
  <div class="mode-card" data-mode="hard"><div class="m-title" style="color:#F44336">어려움</div><div class="m-desc">탄막이 보다 빠른 속도로 날아옵니다.</div></div>
  <div class="mode-card" data-mode="extreme"><div class="m-title" style="color:#9C27B0">익스트림</div><div class="m-desc">깨라고 만든 모드가 아닙니다. 매우 극한의 난이도를 가지고 있습니다. </div></div>
  <div class="back-btn" id="backToMenu">돌아가기</div>
</div>

<div id="select" class="hidden">  
  <div class="scene-title">캐릭터 선택</div>
  <div class="char-row" id="charRow"></div>  
  <div class="back-btn" id="backToMode">돌아가기</div>
</div>  

<div id="game" class="hidden">  
  <div id="topUI">
      <div class="score-box">
          <div id="badgeContainer"></div>
          <div id="collisionDisplay" class="hidden">충돌: 0</div>
          <div class="ui-item" id="scoreDisplay">점수: 0</div>
      </div>
      <div class="btn-small" id="exitBtn">메뉴로</div>
  </div>
  <div class="frame" id="gameFrame">  
    <canvas id="c" width="500" height="500"></canvas>
    <div id="overlay" class="hidden">
        <div class="overlay-content" id="pauseMenu">
            <div class="overlay-msg">메뉴로 나가시겠습니까?</div>
            <div class="overlay-btns">
                <div class="overlay-btn" id="confirmExit">나가기</div>
                <div class="overlay-btn" id="cancelExit">취소하기</div>
            </div>
        </div>
        <div id="countdown" class="hidden countdown-text">3</div>
    </div>
  </div>  
  <div class="controls">  
    <div class="ctrl left"><div class="arrow"></div></div>  
    <div class="ctrl right"><div class="arrow"></div></div>  
  </div>  
</div>  
</div>  

<script>  
const menu = document.getElementById("menu"), modeSelect = document.getElementById("modeSelect"), select = document.getElementById("select"), game = document.getElementById("game");  
const scoreDisplay = document.getElementById("scoreDisplay"), collisionDisplay = document.getElementById("collisionDisplay"), badgeContainer = document.getElementById("badgeContainer");
const exitBtn = document.getElementById("exitBtn"), overlay = document.getElementById("overlay"), pauseMenu = document.getElementById("pauseMenu"), countdownEl = document.getElementById("countdown"), confirmExit = document.getElementById("confirmExit"), cancelExit = document.getElementById("cancelExit"), gameFrame = document.getElementById("gameFrame");

const menuCanvas = document.getElementById("menuCanvas"), mctx = menuCanvas.getContext("2d");
let menuParticles = [];
function resizeMenuCanvas() { menuCanvas.width = window.innerWidth; menuCanvas.height = window.innerHeight; }
window.onresize = resizeMenuCanvas; resizeMenuCanvas();

let currentMode = 'hard', isDeltaUnlocked = false, exitClickCount = 0;

const exitRealBtn = document.getElementById("exitRealBtn");
const deltaHint = document.getElementById("deltaHint");

exitRealBtn.onclick = (e) => {
    exitClickCount++;
    const rect = exitRealBtn.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    if (exitClickCount === 5) {
        exitRealBtn.style.transform = "rotate(15deg)";
        spawnMenuParticles(centerX, centerY, 15, 2, "#303030");
    } else if (exitClickCount === 9) {
        exitRealBtn.style.transform = "rotate(30deg)";
        spawnMenuParticles(centerX, centerY, 30, 3, "#303030");
    } else if (exitClickCount === 11) {
        exitRealBtn.classList.add("hidden");
        deltaHint.style.opacity = "1";
        spawnMenuParticles(centerX, centerY, 60, 5, "#303030");
        isDeltaUnlocked = true;
    } else if (exitClickCount < 11) {
        spawnMenuParticles(centerX, centerY, 3, 1, "#303030");
    }
};

function spawnMenuParticles(x, y, count, size, color) {
    for (let i = 0; i < count; i++) {
        menuParticles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            size: Math.random() * size + 2,
            life: 1,
            color: color
        });
    }
}

function updateMenuParticles() {
    mctx.clearRect(0, 0, menuCanvas.width, menuCanvas.height);
    for (let i = menuParticles.length - 1; i >= 0; i--) {
        let p = menuParticles[i];
        p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life -= 0.02;
        if (p.life <= 0) { menuParticles.splice(i, 1); continue; }
        mctx.fillStyle = `rgba(48, 48, 48, ${p.life})`;
        mctx.fillRect(p.x, p.y, p.size, p.size);
    }
    requestAnimationFrame(updateMenuParticles);
}
updateMenuParticles();

document.getElementById("startBtn").onclick = () => { menu.classList.add("hidden"); modeSelect.classList.remove("hidden"); };
document.getElementById("backToMenu").onclick = () => { modeSelect.classList.add("hidden"); menu.classList.remove("hidden"); };
document.getElementById("backToMode").onclick = () => { select.classList.add("hidden"); modeSelect.classList.remove("hidden"); };

const modeData = { easy: { spawnTime: 300, speedMult: 0.7 }, normal: { spawnTime: 220, speedMult: 0.85 }, hard: { spawnTime: 180, speedMult: 1.0 }, extreme: { spawnTime: 120, speedMult: 1.15 } };
const chars = {
 alpha:{ color:"#FFFFFF", dash:"#FFD700", name:"Alpha", greek:"α", shape:'rect' },  
 gamma:{ color:"#FFD966", dash:"#FF8C00", name:"Gamma", greek:"γ", shape:'rect', speedBoost: 1.2, dashExtend: 120 },  
 epsilon:{ color:"#66CCFF", dash:"#7F7AFF", parry:72, name:"Epsilon", greek:"ε", shape:'rect' },  
 kappa:{ color:"#66FF66", dash:"#2AA24E", name:"Kappa", greek:"κ", shape:'rect' },  
 delta:{ color:"#FFFFFF", dash:"#FFFFFF", name:"Delta", greek:"δ", shape:'dynamic', isDev: true, speedBoost: 1.0, dashExtend: 0 },
 omega:{ color:"#DC422D", dash:"#B63015", name:"Omega", greek:"ω", shape:'diamond' } 
};

document.querySelectorAll('.mode-card').forEach(card => {
    card.onclick = () => { currentMode = card.dataset.mode; modeSelect.classList.add("hidden"); renderCharSelect(); select.classList.remove("hidden"); };
});

let current="alpha";  
function renderCharSelect() {
    const row = document.getElementById("charRow"); row.innerHTML = '';
    Object.keys(chars).forEach(k => {
        if(currentMode === 'extreme' && !['omega','delta'].includes(k)) return;
        if(currentMode !== 'extreme' && k === 'omega') return;
        if(chars[k].isDev && !isDeltaUnlocked) return;
        const b = document.createElement("div"); b.className = "char-btn";
        const pv = document.createElement("canvas"); pv.width = 44; pv.height = 44; pv.className = "char-preview";
        const pctx = pv.getContext("2d");
        if(chars[k].shape !== 'dynamic') { pctx.lineWidth = 4; pctx.strokeStyle = chars[k].color; if(chars[k].shape === 'diamond') { pctx.translate(22, 22); pctx.rotate(Math.PI/4); pctx.strokeRect(-11,-11,22,22); } else { pctx.strokeRect(10, 10, 24, 24); } }
        const n = document.createElement("div"); n.className = "char-name"; n.textContent = `${chars[k].name}\n(${chars[k].greek})`;
        b.appendChild(pv); b.appendChild(n); b.onclick = () => { current = k; select.classList.add("hidden"); game.classList.remove("hidden"); startGame(); }; row.appendChild(b);
    });
}
  
const canvas=document.getElementById("c"), ctx=canvas.getContext("2d"), W=canvas.width, H=canvas.height;  
let player={ x:W/2, y:H-52, size:19, stroke:7, speed:3.8, dashing:false, dashDir:0, dashTime:0, dashEndTime: 0, wallHits: 0, active:true, polySides: 5, polyTimer: 0, alphaInvincible: false };  
let trails=[], particles=[], bullets=[], effects=[], input={l:false,r:false}, tap={l:0,r:0}, score = 0, displayScore = 0, isGameOver = false, gameOverPhase = 0, gameOverTimer = 0, spawnTimer = 0, isPaused = false, isGaveUp = false;
let boss = null, bossCount = 0, nextBossScore = 100, bossWaitPhase = 0, shakeTime = 0, isParryFrozen = false, parryFrozenTimer = 0;

function hexToRgb(h){ const n=parseInt(h.slice(1),16); return `${n>>16&255},${n>>8&255},${n&255}`; }
function randomColor() { return ["#FF5252", "#FF4081", "#E040FB", "#7C4DFF", "#536DFE", "#448AFF", "#40C4FF", "#18FFFF", "#64FFDA", "#69F0AE", "#B2FF59", "#EEFF41", "#FFFF00", "#FFD740", "#FFAB40", "#FF6E40"][Math.floor(Math.random()*16)]; }
function getRainbowColor(t) { return `hsl(${t % 360}, 100%, 50%)`; }

class Bullet {
    constructor(type, x, y, angleDeg, speed, color, sizeOverride = null, isParry = false) {
        this.type = type; this.x = x; this.y = y; this.vx = Math.sin(angleDeg * Math.PI / 180) * speed; this.vy = Math.cos(angleDeg * Math.PI / 180) * speed;
        this.speed = speed; this.color = color; this.rotation = Math.random() * Math.PI * 2; this.rotSpeed = (Math.random() - 0.5) * 0.15; 
        this.processed = false; this.dead = false; this.isParry = isParry; this.parryTargeting = false; this.curveFactor = 0; 
        this.isInstaKill = (currentMode === 'extreme' && Math.random() < 0.20 && !isParry); this.isBossBullet = false; 
        if (type === 'circle') { this.size = sizeOverride || (12 + Math.random()*4-1); this.points = 1; } 
        else if (type === 'triangle') { this.size = sizeOverride || 18; this.points = 2; this.hasSplit = false; } 
        else if (type === 'square') { this.size = sizeOverride || 20; this.points = 1; } 
        else if (type === 'star') { this.size = sizeOverride || 16; this.points = 2; this.bounced = false; this.maxBounces = 1; this.bounceCount = 0; } 
        else if (type === 'pentagon') { this.size = sizeOverride || 18; this.points = 3; this.effectSpawned = false; } 
        else if (type === 'hexagon') { this.size = sizeOverride || 18; this.points = 4; this.effectSpawned = false; } 
        else if (type === 'triangle_small') { this.size = sizeOverride || 10; this.points = 1; }
        this.lineWidth = 5; 
    }
    update(dt) {
        if (this.dead) return; if (isParryFrozen && !this.parryTargeting) return;
        if (this.parryTargeting) {
            if (boss && boss.hp > 0) {
                const dx = boss.x - this.x, dy = boss.y - this.y, dist = Math.hypot(dx, dy);
                const baseVX = (dx / dist) * 14, baseVY = (dy / dist) * 14;
                if (this.curveFactor !== 0) { const perpX = -baseVY * this.curveFactor, perpY = baseVX * this.curveFactor, lifeRatio = Math.max(0, dist / 300); this.vx = baseVX + perpX * lifeRatio; this.vy = baseVY + perpY * lifeRatio; } else { this.vx = baseVX; this.vy = baseVY; }
                this.x += this.vx; this.y += this.vy; if (dist < 35) { boss.hit(this.isParry); this.dead = true; } 
            } else { this.vx = 0; this.vy = -14; this.x += this.vx; this.y += this.vy; }
            return;
        }
        this.x += this.vx; this.y += this.vy; this.rotation += this.rotSpeed;
        if (this.type === 'triangle' && !this.hasSplit && this.y > H/2) {
            this.hasSplit = true; this.dead = true; spawnParticles(this.x, this.y, [this.color], 8);
            let splitSize = this.isParry ? this.size : this.size * 0.6;
            let b1 = new Bullet('triangle_small', this.x, this.y, 30, this.speed, this.color, splitSize, this.isParry); 
            let b2 = new Bullet('triangle_small', this.x, this.y, 330, this.speed, this.color, splitSize, this.isParry);
            b1.isBossBullet = this.isBossBullet; b2.isBossBullet = this.isBossBullet; bullets.push(b1); bullets.push(b2); return;
        }
        if (this.type === 'star') {
            if (this.y - this.size < 0 && this.vy < 0) { this.vy *= -1; spawnParticles(this.x, 0, [this.color], 5); }
            if (this.x - this.size < 0 || this.x + this.size > W) { if(this.bounceCount < (this.maxBounces || 1)) { this.bounceCount++; this.vx = -this.vx; spawnParticles(this.x < W/2?0:W, this.y, [this.color], 5); } } 
        }
        if (this.type === 'pentagon' && !this.effectSpawned && this.y >= H) { this.effectSpawned = true; effects.push(new PentagonEffect(this.x, this.color)); }
        if (this.type === 'hexagon' && !this.effectSpawned && this.y >= H) { this.effectSpawned = true; effects.push(new HexagonEffect(this.x, this.color, this.size)); }
        const outB = this.y > H + 50, outS = (this.x < -100 || this.x > W + 100) || (this.y < -100);
        if (!this.processed && (outB || outS)) { if (!this.isBossBullet) { score += (this.type === 'triangle_small' ? 1 : this.points); scoreDisplay.textContent = "점수: " + score; } this.processed = true; if(outB||outS) { spawnParticles(this.x, Math.min(H, this.y), [this.color], 3); this.dead = true; } }
        if (outB || outS) this.dead = true;
    }
    draw(ctx) {
        if (this.dead) return; ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.lineJoin = "round"; ctx.lineWidth = this.lineWidth;
        const dc = this.isParry ? getRainbowColor(Date.now() * 0.5) : this.color; ctx.strokeStyle = dc;
        if(this.isInstaKill) { ctx.shadowBlur = 12; ctx.shadowColor = "red"; }
        const t = this.type === 'triangle_small' ? 'triangle' : this.type;
        if (t === 'circle') { ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI*2); ctx.stroke(); } 
        else if (t === 'star') { drawStar(ctx, 0, 0, 5, this.size, this.size * 0.45); ctx.stroke(); } 
        else { let s = (t === 'triangle' ? 3 : t === 'pentagon' ? 5 : t === 'hexagon' ? 6 : 4); drawPolygon(ctx, 0, 0, this.size, s); }
        ctx.restore();
    }
}

class BaseBoss {
    constructor() { 
        this.x = W/2; this.y = -100; this.targetY = H/4; this.size = 60; this.hp = 5; this.maxHp = 5; 
        this.color = (currentMode === 'extreme') ? "#FF0000" : "#BAAB81"; this.rotation = 0; 
        this.state = "entering"; this.timer = 0; this.patterns = []; this.dead = false;
        this.dyingTimer = 0;
    }
    updateBase(dt) { 
        if (this.hp <= 0) {
            this.dyingTimer += dt; shakeTime = 3;
            if (this.dyingTimer > 1500) { this.die(); return false; }
            return false;
        }
        if (isParryFrozen) return false; 
        if (this.state === "entering") { 
            this.y += 3; if (this.y >= this.targetY) { this.y = this.targetY; this.state = "idle"; } return false; 
        } 
        return true; 
    }
    hit(fromParry = false) { 
        if (this.hp <= 0) return 0;
        let dmg = 1;
        if (fromParry && current === 'kappa') dmg = 2;
        this.hp -= dmg; 
        shakeTime = 20; 
        spawnParticles(this.x, this.y, [this.color, "#FFF"], 20, 1.5); 
        isParryFrozen = false; 
        return dmg;
    }
    die() { 
        this.dead = true; boss = null; bullets = []; effects = []; bossCount++; 
        let bt = (this instanceof MeteorBoss) ? 'star' : (this instanceof SnowballBoss) ? 'circle-fill rainbow' : 'rect'; 
        addBadge(bt + ' rainbow'); nextBossScore += 100; bossWaitPhase = 0; 
        spawnParticles(this.x, this.y, [this.color, "#FFF", "#FF0000", "#00FF00", "#0000FF"], 100, 4); 
    }
    getDyingColor() { return getRainbowColor(Date.now() * 0.8); }
}

class BossDummy extends BaseBoss {
    constructor() { super(); this.lineColor = (currentMode === 'extreme' ? "#880000" : "#786E53"); this.rainTimer = 0; this.extraPatternTimer = 0; this.extraPatterns = []; }
    update(dt) {
        if (!this.updateBase(dt)) return; this.rotation += 0.08; this.timer += dt; this.rainTimer += dt; this.extraPatternTimer += dt;
        let iv = (currentMode === 'extreme' ? 500 : 800); if (this.timer > iv) { this.timer = 0; this.patterns.push({ tx: player.x, ty: player.y, time: 0, fired: false }); }
        if (this.rainTimer > 600) { this.rainTimer = 0; let b = new Bullet('square', Math.random()*W, -30, 180, 4, this.color, 24); b.isBossBullet = true; bullets.push(b); }
        if (this.extraPatternTimer > 3000) { this.extraPatternTimer = 0; [{x: W/2, y: 0}, {x: 0, y: H/2}, {x: W, y: H/2}].forEach(p => { this.extraPatterns.push({ sx: p.x, sy: p.y, tx: player.x, ty: player.y, time: 0, fired: false }); }); }
        this.extraPatterns.forEach(p => { p.time += dt; if (p.time > 500 && !p.fired) { p.fired = true; let a = Math.atan2(p.tx - p.sx, p.ty - p.sy) * 180 / Math.PI; let b = new Bullet('square', p.sx, p.sy, a, 8, this.color, 12); b.isBossBullet = true; b.rotSpeed = 0.3; bullets.push(b); } });
        this.extraPatterns = this.extraPatterns.filter(p => p.time < 1000);
        this.patterns.forEach(p => { p.time += dt; if (p.time > 800 && !p.fired) { p.fired = true; let a = Math.atan2(p.tx - this.x, p.ty - this.y) * 180 / Math.PI; let b = new Bullet('circle', this.x, this.y, a, (currentMode === 'extreme' ? 9 : 7), this.color, 13, Math.random() < 0.5); b.isBossBullet = true; bullets.push(b); } });
        this.patterns = this.patterns.filter(p => p.time < 1200);
    }
    draw(ctx) {
        if (this.hp > 0) {
            [...this.patterns, ...this.extraPatterns].forEach(p => { let pg = 0; if (p.fired) { pg = (p.time - (p.sx !== undefined ? 500 : 800)) / 400; if (pg > 1) pg = 1; } if (pg < 1) { ctx.save(); ctx.beginPath(); ctx.setLineDash([15, 10]); ctx.strokeStyle = this.lineColor; ctx.lineWidth = 6; ctx.globalAlpha = 0.6 * (p.time/(p.sx !== undefined ? 500 : 800)); let sx = p.sx ?? this.x, sy = p.sy ?? this.y, cx = sx + (p.tx - sx) * pg, cy = sy + (p.ty - sy) * pg; ctx.moveTo(cx, cy); ctx.lineTo(p.tx, p.ty); ctx.stroke(); ctx.restore(); } });
        }
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.lineWidth = 14; 
        ctx.strokeStyle = this.hp <= 0 ? this.getDyingColor() : this.color;
        ctx.strokeRect(-this.size/2, -this.size/2, this.size, this.size); ctx.restore();
    }
}

class MeteorBoss extends BaseBoss {
    constructor() { super(); this.color = (currentMode === 'extreme' ? "#FF0000" : "#784B31"); this.phase = 0; this.burstCount = 0; this.isResting = false; this.restTimer = 0; }
    update(dt) {
        if (!this.updateBase(dt)) return; if (this.isResting || this.timer < 800) { let tr = Math.atan2(player.y - this.y, player.x - this.x) + Math.PI/2; let d = tr - this.rotation; while (d < -Math.PI) d += Math.PI * 2; while (d > Math.PI) d -= Math.PI * 2; this.rotation += d * 0.1; }
        if (this.isResting) { this.restTimer += dt; if (this.restTimer > 3000) { this.isResting = false; this.restTimer = 0; this.burstCount = 0; } return; }
        this.timer += dt; if (this.timer > 500) { this.timer = 0; this.fireBurst(); this.burstCount++; if (this.burstCount >= 3) { this.isResting = true; this.phase++; } }
    }
    fireBurst() { let s = (currentMode === 'extreme' ? 7 : 5); for (let i = 0; i < 5; i++) { let pa = this.rotation - Math.PI/2 + (i * Math.PI * 2 / 5); let tx = this.x + Math.cos(pa) * this.size, ty = this.y + Math.sin(pa) * this.size; let b = new Bullet('star', tx, ty, 90 - (pa * 180 / Math.PI), s, this.color, 16, Math.random() < 0.5); b.isBossBullet = true; bullets.push(b); } }
    draw(ctx) { 
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.rotation); ctx.lineWidth = 12; 
        const dc = this.hp <= 0 ? this.getDyingColor() : this.color;
        ctx.strokeStyle = dc; drawStar(ctx, 0, 0, 5, this.size, this.size * 0.45); ctx.stroke(); ctx.restore(); 
    }
}

class SnowballBoss extends BaseBoss {
    constructor() { super(); this.color = (currentMode === 'extreme' ? "#FF0000" : "#B4B9BF"); this.lineWidth = (currentMode === 'extreme' ? 18 : 10); this.baseSize = 40; this.size = 40; this.vx = 0; this.vy = 0; this.lineAlpha = 0; this.attackCycles = 0; this.hp = 5; this.maxHp = 5; }
    hit(fromParry = false) {
        if (this.hp <= 0) return 0;
        let dmg = 1;
        if (fromParry && current === 'kappa') dmg = 2;
        
        // 패링 탄환은 오로지 페이즈 스킵용: 맞을 시 즉시 복귀 상태로 전환
        if (fromParry) {
            this.attackCycles += dmg;
            if (this.attackCycles < 5) { this.state = "returning"; this.timer = 0; }
        } else {
            this.hp -= dmg; // 일반 히트 (거의 발생하지 않지만 보존)
        }
        
        if (this.attackCycles >= 5) this.hp = 0; // 5페이즈 도달 시 사망 처리
        
        shakeTime = 20; 
        spawnParticles(this.x, this.y, [this.color, "#FFF"], 20, 1.5); 
        isParryFrozen = false; 
        return dmg;
    }
    update(dt) {
        if (this.hp <= 0) { this.updateBase(dt); return; }
        if (isParryFrozen) return; 
        if (this.state === "entering") { this.y += 2.5; if (this.y >= H/3) { this.y = H/3; this.state = "ready"; } return; }
        if (player.active && !isGameOver && !['delta'].includes(current)) { if (Math.hypot(player.x - this.x, player.y - this.y) < (this.size + player.size/2)) { if (!isInvincible()) handleCollision(); } }
        if (this.state === "ready") { this.timer += dt; this.lineAlpha = Math.min(1, this.timer / 400); if (this.timer > 600) { this.state = "aiming"; this.timer = 0; this.lineTargetX = player.x; this.lineTargetY = player.y; } }
        else if (this.state === "aiming") { this.timer += dt; if (this.timer > 400) { this.state = "dashing"; this.bounceCount = 0; this.lineAlpha = 0; let a = Math.atan2(this.lineTargetY - this.y, this.lineTargetX - this.x); this.vx = Math.cos(a) * 12; this.vy = Math.sin(a) * 12; } }
        else if (this.state === "dashing") {
            this.x += this.vx; this.y += this.vy; spawnParticles(this.x, this.y, [(currentMode === 'extreme' ? "#FF0000" : "#FFFFFF")], 1, 0.5);
            if (this.x - this.size < 0 || this.x + this.size > W) { this.vx *= -1; this.onBounce(); }
            if (this.y - this.size < 0) { 
                this.vy *= -1; this.onBounce(); 
                let isP = Math.random() < 0.15;
                let t1 = new Bullet('triangle', this.x, this.y, 30, 6, this.color, 12, isP); 
                let t2 = new Bullet('triangle', this.x, this.y, 330, 6, this.color, 12, isP); 
                t1.isBossBullet = true; t2.isBossBullet = true; bullets.push(t1, t2); 
            } else if (this.y + this.size > H) { this.vy *= -1; this.onBounce(); }
            if (this.bounceCount >= 10) { this.state = "returning"; this.timer = 0; } 
        } else if (this.state === "returning") {
            let dx = W/2 - this.x, dy = H/3 - this.y, dist = Math.hypot(dx, dy); this.size = Math.min(this.baseSize, this.size + dt * 0.05);
            if (dist < 15) { 
                this.x = W/2; this.y = H/3; this.size = this.baseSize; this.timer += dt; 
                if (this.timer > 800) { 
                    this.attackCycles++; 
                    if (this.attackCycles >= 5) { this.hp = 0; } else { this.state = "ready"; }
                    this.timer = 0; 
                } 
            } else { this.x += dx * 0.15; this.y += dy * 0.15; }
        }
    }
    onBounce() { this.bounceCount++; this.size = Math.max(15, this.baseSize * (1 - this.bounceCount/30)); spawnParticles(this.x, this.y, [this.color], 10); }
    draw(ctx) {
        ctx.save(); 
        const dc = this.hp <= 0 ? this.getDyingColor() : this.color;
        ctx.strokeStyle = dc; ctx.lineWidth = this.lineWidth; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.stroke();
        if (this.hp > 0 && (this.state === "ready" || this.state === "aiming") && this.lineAlpha > 0) { ctx.setLineDash([15, 10]); ctx.lineWidth = 6; ctx.globalAlpha = 0.6 * this.lineAlpha; ctx.beginPath(); ctx.moveTo(this.x, this.y); let tx = this.state === "aiming" ? this.lineTargetX : player.x, ty = this.state === "aiming" ? this.lineTargetY : player.y; ctx.lineTo(tx, ty); ctx.stroke(); }
        ctx.restore();
    }
}

function addBadge(s) { const b = document.createElement("div"); b.className = "badge " + s; badgeContainer.appendChild(b); }
class PentagonEffect {
    constructor(x, color) { this.x = x; this.color = color; this.timer = 0; this.fired = false; this.dead = false; this.bulletY = H; }
    update(dt) { if (isParryFrozen) return; this.timer += dt; if (this.timer > 1000 && !this.fired) { this.fired = true; let b = new Bullet('circle', this.x, H + 20, 180, 0, this.color, 12); b.vx = 0; b.vy = -10; b.isRisingLineEraser = true; bullets.push(b); } let tr = bullets.find(b => b.isRisingLineEraser && Math.abs(b.x - this.x) < 1); if(tr) this.bulletY = tr.y; else if(this.fired) this.bulletY = -50; if (this.timer > 3000 || (this.fired && this.bulletY < -10)) this.dead = true; }
    draw(ctx) { if(this.bulletY < 0) return; ctx.save(); ctx.beginPath(); ctx.setLineDash([10, 10]); ctx.strokeStyle = this.color; ctx.globalAlpha = 0.5; ctx.lineWidth = 4; ctx.moveTo(this.x, 0); ctx.lineTo(this.x, this.bulletY); ctx.stroke(); ctx.restore(); }
}
class HexagonEffect {
    constructor(x, color, hs) { this.x = x; this.color = color; this.maxSize = hs; this.currentSize = 0; this.timer = 0; this.lethal = false; this.dead = false; this.alpha = 0.2; this.phase = 0; }
    update(dt) { if (isParryFrozen) return; this.timer += dt; if (this.phase === 0) { if(this.timer > 600) this.phase = 1; } else if (this.phase === 1) { this.currentSize += dt * 0.08; this.alpha = 0.3; if(this.currentSize >= this.maxSize) { this.currentSize = this.maxSize; this.phase = 2; this.lethal = true; this.alpha = 1.0; } } else if (this.phase === 2) { if (player.active && !isGameOver && !['delta'].includes(current)) { if (Math.abs(player.x - this.x) < (this.currentSize + player.size/2)) { if (!isInvincible()) handleCollision(); } } if (this.timer > 1200) { this.alpha -= dt * 0.008; if (this.alpha <= 0) this.dead = true; } } }
    draw(ctx) { ctx.save(); if(this.phase === 0) { ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.strokeStyle = this.color; ctx.globalAlpha = 0.4; ctx.lineWidth = 2; ctx.moveTo(this.x-10,0); ctx.lineTo(this.x-10,H); ctx.moveTo(this.x+10,0); ctx.lineTo(this.x+10,H); ctx.stroke(); } else { ctx.fillStyle = this.color; ctx.globalAlpha = Math.max(0, this.alpha); ctx.fillRect(this.x - this.currentSize, 0, this.currentSize * 2, H); } ctx.restore(); }
}

function drawPolygon(ctx, x, y, r, s) { ctx.beginPath(); const a = (Math.PI * 2)/s, ao = -Math.PI/2; for (let i = 0; i < s; i++) ctx.lineTo(x + r * Math.cos(ao + a * i), y + r * Math.sin(ao + a * i)); ctx.closePath(); ctx.stroke(); }
function drawStar(ctx, cx, cy, sp, or, ir) { let rot = Math.PI/2*3, step = Math.PI/sp; ctx.beginPath(); ctx.moveTo(cx, cy-or); for (let i=0; i<sp; i++) { ctx.lineTo(cx+Math.cos(rot)*or, cy+Math.sin(rot)*or); rot+=step; ctx.lineTo(cx+Math.cos(rot)*ir, cy+Math.sin(rot)*ir); rot+=step; } ctx.closePath(); }

function startGame() {
    player.x = W/2; player.y = H-52; player.active = true; player.dashing = false; player.dashTime = 0; player.dashEndTime = 0; player.wallHits = 0; player.speed = 3.8 * (chars[current].speedBoost || 1); player.polySides = 5; player.polyTimer = 0;
    player.alphaInvincible = (current === 'alpha' && isDeltaUnlocked);
    bullets = []; effects = []; trails = []; particles = []; score = 0; displayScore = 0; scoreDisplay.textContent = "점수: 0"; isGameOver = false; isGaveUp = false; spawnTimer = 0; badgeContainer.innerHTML = ''; bossCount = 0; collisionDisplay.classList.add("hidden"); overlay.classList.add("hidden"); isPaused = false; boss = null; isParryFrozen = false; nextBossScore = 100; bossWaitPhase = 0;
}
function isInvincible() { return player.dashing || (Date.now() - player.dashEndTime < 200); }
function spawnBulletLogic() {
    if (boss) return; if (bossWaitPhase === 0 && score >= nextBossScore) bossWaitPhase = 1; 
    if (bossWaitPhase === 1) { if (bullets.filter(b => !b.isBossBullet).length === 0 && effects.length === 0) { bossWaitPhase = 2; let r = Math.random(); if (r < 0.33) boss = new BossDummy(); else if (r < 0.66) boss = new MeteorBoss(); else boss = new SnowballBoss(); } return; }
    let t = 'circle', ar = 30, c = (currentMode === 'extreme' ? '#FF0000' : randomColor()), r = Math.random()*100;
    if (r < 60) t = 'circle'; else if (r < 75) t = 'triangle'; else if (r < 85) { t = 'star'; ar=60; } else if (r < 92) t = 'square'; else if (r < 96) { t = 'pentagon'; ar=10; } else { t = 'hexagon'; ar=10; } 
    let a = (t === 'star' ? (Math.random()<0.5?-1:1)*(10+Math.random()*50) : (Math.random()-0.5)*2*ar);
    let s = (3.0 + Math.random()*2.5) * modeData[currentMode].speedMult * (t === 'star' ? 1.3 : t === 'square' ? 0.8 : 1); 
    bullets.push(new Bullet(t, Math.random()*(W-40)+20, -30, a, s, c));
}

function tryDash(dir){ if(isGameOver || !player.active || isPaused || isParryFrozen) return; const now=Date.now(), k=dir<0?"l":"r"; if(now-tap[k]<260 && !player.dashing){ player.dashing=true; player.dashDir=dir; player.dashTime=0; } tap[k]=now; }  
function spawnParticles(x,y,cols, count=10, ss=1){ for(let i=0;i<count;i++) particles.push({ x,y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:1, size: (Math.random()*4+2)*ss, color:cols[Math.floor(Math.random()*cols.length)] }); }

function handleCollision() {
    if (player.alphaInvincible) {
        player.alphaInvincible = false;
        spawnParticles(player.x, player.y, ["#FF0000", "#FFFF00", "#00FF00", "#00FFFF", "#0000FF", "#FF00FF"], 60, 3);
        bullets = []; effects = []; if (boss) boss.die(); return;
    }
    gameOver();
}

function gameOver() { if (isGameOver) return; isGameOver = true; gameOverPhase = 1; gameOverTimer = 0; }

exitBtn.onclick = () => { if(isGameOver || isPaused) return; isPaused = true; overlay.classList.remove("hidden"); pauseMenu.classList.remove("hidden"); countdownEl.classList.add("hidden"); };
confirmExit.onclick = () => { isPaused = false; overlay.classList.add("hidden"); isGaveUp = true; gameOver(); };
cancelExit.onclick = () => { pauseMenu.classList.add("hidden"); countdownEl.classList.remove("hidden"); let c = 3; countdownEl.textContent = c; let i = setInterval(() => { c--; if(c > 0) countdownEl.textContent = c; else { clearInterval(i); overlay.classList.add("hidden"); isPaused = false; } }, 1000); };
gameFrame.onclick = () => { if (isGameOver && gameOverPhase >= 9) location.reload(); };

function update(dt){
  if (isPaused) return;
  if (isGameOver) {
      gameOverTimer += dt;
      if (gameOverPhase === 1 && gameOverTimer >= 300) { gameOverPhase = 2; gameOverTimer = 0; player.active = false; trails = []; spawnParticles(player.x, player.y, [chars[current].color], 50, 2); }
      else if (gameOverPhase >= 2) { 
          if(gameOverPhase === 5) { if (displayScore < score) { displayScore += Math.max(1, Math.ceil(score / 60)); if(displayScore >= score) { displayScore = score; gameOverPhase = 6; gameOverTimer = 0; } } else { gameOverPhase = 6; gameOverTimer = 0; } }
          else if(gameOverPhase === 6 && gameOverTimer > 1200) gameOverPhase = 7;
          else if(gameOverPhase === 7) { if (displayScore < (score + bossCount * 100)) { displayScore += 5; if(displayScore >= (score + bossCount * 100)) { displayScore = (score + bossCount * 100); gameOverPhase = 8; } } else { gameOverPhase = 8; } }
          else if(gameOverPhase === 2 && gameOverTimer > 800) gameOverPhase = 3;
          else if(gameOverPhase === 3 && gameOverTimer > 1600) gameOverPhase = 4;
          else if(gameOverPhase === 4 && gameOverTimer > 1800) gameOverPhase = 5;
          else if(gameOverPhase === 8 && gameOverTimer > 1000) gameOverPhase = 9;
      }
      particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.life-=dt/600; }); particles=particles.filter(p=>p.life>0); return; 
  }
  if (isParryFrozen) { parryFrozenTimer -= dt; if (parryFrozenTimer <= 0) isParryFrozen = false; bullets.forEach(b => { if(b.parryTargeting) b.update(dt); }); particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.life-=dt/600; }); particles=particles.filter(p=>p.life>0); return; }
  spawnTimer += dt; if (spawnTimer > modeData[currentMode].spawnTime) { spawnBulletLogic(); spawnTimer = 0; }
  if (current === 'delta') { player.polyTimer += dt; if (player.polyTimer > 30) { player.polyTimer = 0; player.polySides = 3 + Math.floor(Math.random()*7); } }
  if (boss) boss.update(dt);
  if(player.dashing){
    player.x+=player.dashDir*12; player.dashTime+=dt; const hitL = player.x-player.size/2<=0, hitR = player.x+player.size/2>=W;  
    if(hitL||hitR){ 
        player.wallHits++; 
        let threshold = (current === 'delta') ? 50 : 200;
        let deadLimit = (current === 'delta') ? Infinity : 500;
        if(player.wallHits >= threshold) { collisionDisplay.classList.remove("hidden"); collisionDisplay.textContent = "충돌: " + player.wallHits; } 
        if (player.wallHits >= deadLimit) gameOver(); 
        const wallX = hitL ? 0 : W; player.x = hitL ? player.size/2 : W-player.size/2; spawnParticles(wallX,player.y,[chars[current].color], 10); player.x += (hitL?1:-1)*18; 
    }  
    if(chars[current].dash || player.alphaInvincible) { 
        let tCol = (player.alphaInvincible) ? getRainbowColor(Date.now()*0.5) : chars[current].dash;
        if (current === 'delta') trails.push({x:player.x, y:player.y, a:1, color:getRainbowColor(Date.now()*0.5), shape: 'dynamic', sides: player.polySides}); 
        else trails.push({x:player.x, y:player.y, a:1, color:tCol, shape: chars[current].shape === 'diamond' ? 'diamond' : 'rect'}); 
    }
    if(player.dashTime > 200 + (chars[current].dashExtend || 0)) { player.dashing=false; player.dashEndTime = Date.now(); }
  } else { if(input.l) player.x-=player.speed; if(input.r) player.x+=player.speed; }  
  player.x=Math.max(player.size/2,Math.min(W-player.size/2,player.x));  
  trails.forEach(t=>t.a-=dt/300); trails=trails.filter(t=>t.a>0); particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.life-=dt/600; }); particles=particles.filter(p=>p.life>0);
  bullets.forEach(b => {
      b.update(dt);
      if (player.active && !b.dead) {
          let cd = player.size/2 + b.size; if (current === 'epsilon' && b.isParry) cd = chars.epsilon.parry + b.size;
          if (Math.hypot(player.x - b.x, player.y - b.y) < cd) {
              if (b.isParry && boss && boss.hp > 0) { 
                  isParryFrozen = true; parryFrozenTimer = 1500; 
                  if (current === 'kappa') { 
                      b.dead = true; 
                      for (let i = 0; i < 2; i++) { 
                          let sb = new Bullet(b.type, b.x, b.y, 0, 10, b.color, b.size / 1.5, true); 
                          sb.parryTargeting = true; sb.curveFactor = (i === 0 ? 0.3 : -0.3); 
                          bullets.push(sb); 
                      } 
                  } else { b.parryTargeting = true; } 
              } 
              else if (current === 'delta') { if(!b.isParry) return; }
              else if (!isInvincible()) handleCollision(); 
          }
      }
  });
  bullets = bullets.filter(b => !b.dead); effects.forEach(e => e.update(dt)); effects = effects.filter(e => !e.dead);
}  
  
function draw(){
  ctx.save(); if (shakeTime > 0) { ctx.translate((Math.random()-0.5)*shakeTime, (Math.random()-0.5)*shakeTime); shakeTime--; }
  ctx.clearRect(0,0,W,H); effects.forEach(e => e.draw(ctx)); if (boss) boss.draw(ctx); bullets.forEach(b => b.draw(ctx));
  trails.forEach(t=>{ ctx.save(); ctx.lineWidth=player.stroke; ctx.strokeStyle=(current === 'delta' || (current === 'alpha' && isDeltaUnlocked)) ? t.color : `rgba(${hexToRgb(t.color)},${t.a})`; ctx.translate(t.x, t.y); if(t.shape === 'dynamic') drawPolygon(ctx, 0, 0, player.size, t.sides); else if(t.shape === 'diamond') { ctx.rotate(Math.PI/4); ctx.strokeRect(-player.size/2, -player.size/2, player.size, player.size); } else ctx.strokeRect(-player.size/2, -player.size/2, player.size, player.size); ctx.restore(); });  
  particles.forEach(p=>{ ctx.fillStyle=`rgba(${hexToRgb(p.color)},${p.life})`; ctx.fillRect(p.x-p.size/2, p.y-p.size/2, p.size, p.size); });  
  if (player.active) {
      ctx.save(); ctx.lineWidth=player.stroke; ctx.strokeStyle = player.alphaInvincible ? getRainbowColor(Date.now()*0.5) : chars[current].color;
      if (isInvincible()) ctx.globalAlpha = 0.6; ctx.translate(player.x, player.y); if(current === 'delta') drawPolygon(ctx, 0, 0, player.size, player.polySides); else if(chars[current].shape === 'diamond') { ctx.rotate(Math.PI/4); ctx.strokeRect(-player.size/2, -player.size/2, player.size, player.size); } else ctx.strokeRect(-player.size/2, -player.size/2, player.size, player.size); ctx.restore();
      if(chars[current].parry){ const r=chars[current].parry; ctx.lineWidth=3; ctx.strokeStyle="rgba(127,122,255,0.4)"; ctx.beginPath(); ctx.rect(player.x-r,player.y-r,r*2,r*2); ctx.stroke(); } 
  } ctx.restore();
  if (isGameOver) {
      if (gameOverPhase >= 3) { ctx.fillStyle = "rgba(0,0,0,0.85)"; ctx.fillRect(0,0,W,H); }
      ctx.textAlign = "center"; ctx.fillStyle = "#FFFFFF";
      if (gameOverPhase >= 3) { ctx.font = "bold 40px sans-serif"; ctx.fillText(isGaveUp ? "GIVE UP" : "GAME OVER", W/2, H/2 - 40); ctx.font = "18px sans-serif"; ctx.fillStyle = "#AAA"; ctx.fillText("최종 점수", W/2, H/2 + 10); }
      if (gameOverPhase >= 4) { ctx.font = "bold 48px sans-serif"; ctx.fillStyle = (gameOverPhase >= 7 && bossCount > 0) ? "#FFD700" : "#FFF"; ctx.fillText(`${displayScore}`, W/2, H/2 + 65); }
      if (gameOverPhase >= 9) { ctx.font = "14px sans-serif"; ctx.fillStyle = "#666"; ctx.fillText("터치하여 메뉴로 이동", W/2, H/2 + 130); }
  }
}  
  
let last=performance.now(); (function loop(t){ const dt=t-last; last=t; update(dt); draw(); requestAnimationFrame(loop); })(last);  
const L=document.querySelector(".left"), R=document.querySelector(".right");  
function handleInput(dir, isDown) { if (dir === 'left') { input.l = isDown; if(isDown) L.classList.add('active'); else L.classList.remove('active'); } if (dir === 'right') { input.r = isDown; if(isDown) R.classList.add('active'); else R.classList.remove('active'); } if (isDown) tryDash(dir === 'left' ? -1 : 1); }
L.ontouchstart = (e) => { e.preventDefault(); handleInput('left', true); }; L.ontouchend = (e) => { e.preventDefault(); handleInput('left', false); }; R.ontouchstart = (e) => { e.preventDefault(); handleInput('right', true); }; R.ontouchend = (e) => { e.preventDefault(); handleInput('right', false); };
L.onmousedown = () => handleInput('left', true); L.onmouseup = () => handleInput('left', false); R.onmousedown = () => handleInput('right', true); R.onmouseup = () => handleInput('right', false);

window.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.key.toLowerCase() === 'a') handleInput('left', true);
    if (e.key.toLowerCase() === 'd') handleInput('right', true);
});
window.addEventListener('keyup', (e) => {
    if (e.key.toLowerCase() === 'a') handleInput('left', false);
    if (e.key.toLowerCase() === 'd') handleInput('right', false);
});
</script>  
</body>  
</html>
